# Everytime-test# 자료구조

### 리스트

리스트는 기본 자료구조로서 여러 데이터를 보관할 수 있다. 배열과 가장 큰 차이점은 **배열**은 **연속된 메모리에 데이터를 저장**하는 반면, **리스트**는 **불연속된 메모리에 데이터를 저장**한다.

- 포인터로 연결된 요소
    
    리스트는 **각 데이터를 담고 있는 요소들을 포인터로 연결**한 자료구조이다. 요소들이 포인터로 연결됐다고 해서 **링크드 리스트(Linked list)**라고도 한다.
    
    ```go
    type Element struct { //구조체
    	Value interface{ }  //데이터를 저장하는 필드
    	Next *Element       //다음 요소의 주소를 저장하는 필드
    	Prev *Element       //이전 요소의 주소를 저장하는 필드
    }
    ```
    
    1. Element는 리스트의 각 요소 데이터를 저장하는 구조체
    2. Value는 실제 요소의 데이터를 저장한 필드인데 interface { } 타입이므로 어떤 타입값도 저장할 수 있다.
    3. Next는 *Element 타입으로 다음 Element 인스턴스의 메모리 주소를 가지고 있다. Next를 사용(포인터)해 다음 인스턴스로 접근할 수 있다.
    4. 다음 요소뿐 아니라 이전 요소도 Prev 포인터로 가진다. 그래서 다음 요소뿐 아니라 이전 요소도 접근할 수 있다. 이것을 양뱡향 리스트이다.
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7a52d369-c1d2-4b51-8b29-335e6ae70f75/Untitled.png)
    
- 리스트 기본 사용법
    
    ```go
    package main
    
    import (
    	"container/list"
    	"fmt"
    )
    
    func main() {
    	v := list.New()       //새로운 리스트 생성
    	e4 := v.PushBack(4)   //리스트 뒤에 요소 추가
    	e1 := v.PushFront(1)  //리스트 앞에 요소 추가
    	v.InsertBefore(3, e4) //e4 요소 앞에 요소 삽입
    	v.InsertAfter(2, e1)  //e1 요소 뒤에 요소 삽입
    
    	for e := v.Front(); e != nil; e = e.Next() { //각 요소 순회
    		fmt.Print(e.Value, " ")
    	}
    	fmt.Println()
    	for e := v.Back(); e != nil; e = e.Prev() { //각 요소 역순 순회
    		fmt.Print(e.Value, " ")
    	}
    }
    ```
    
    1. 새로운 리스트 인스턴스를 만든다. 
    2. PushBack(4)메서드를 통해 Value가 4인 새 요소를 리스트 맨 뒤에 추가한다.
    3. PushFront(1)메서드를 통해 Value가 1인 새 요소를 리스트 맨 앞에 추가한다.
    4. InsertBefore( , )메서드는 두 번째 인수로 입력된 요소 앞에 새 요소를 추가한다. 
        
        (e4앞에 3추가한다)
        
    5. InsertAfter( , )메서드는 두 번째 인수로 입력된 요소 뒤에 값을 추가한다.
        
        (e1뒤에 2추가한다)
        
    6. 각 요소들을 순회한다.  Front() 메서드는 첫 번째 요소를 반환하고 Element의 Next() 메서드는 현재 요소의 다음 요소를 반환한다. 만약 다음 요소가 없다면 nil을 반환한다.
    7. 각 요소들을 역순으로 순회한다. Back() 메서드는 가장 마지막 요소를 반환하고 Element의 Prev() 메서드는 현재 요소의 이전 요소를 반환한다. 이전 요소가 없다면 nil을 반환한다.
- 배열 vs 리스트
    
    배열과 리스트는 모두 여러 요소들을 저장할 수 있는 자료구조이다. 둘의 차이점을 이해하면 데이터 삽입,삭제,접근 등 여러 방법에서 효율적으로 쓸 수 있는 자료구조를 선택할 수 있다.
    
    ---
    
    **<맨 앞에 데이터 추가하기>**
    
    배열 - 각 요소를 한 칸씩 뒤로 밀어내고 맨 앞의 값을 변경하기 때문에 O(n)이 된다.
    
    리스트 - 맨 앞에 요소를 추가하고 연결만 만들어주면 되기 때무에 O(1)이 된다.
    
    맨 앞에 요소를 추가할 때는 배열보다 리스트가 더 빠르다.
    
    ---
    
    **<특정 요소에 접근하기>**
    
    배열에서 인덱스 접근 - 그 인덱스의 메모리 위치를 찾아서 접근하기 때문에 O(1)이 된다.
    
    리스트에서 인덱스 접근 - 각 요소가 포인터로 연결되어 있기 때문에 앞 요소들을 모두 거쳐야 하기 때문에 O(n)이 된다.
    
    ---
    
    **데이터 지역성**
    
    데이터 지역성은 데이터가 밀집한 정도를 말한다. 컴퓨터가 연산을 할 때 높은 확률로 주변 데이터에 대한 연산이 이어지기 때문에 인접해 있을수록 처리 속도가 빨라진다.
    
    **배열은 연속된 메모리로 이뤄진 자료구조**이고, **리스트는 불연속**이기 때문에 **배열이 리스트에 비해서 데이터 지역성이 월등하게 좋다.**
    
    그래서 삽입, 삭제가 빈번하면 리스트가 배열보다 좋긴 하지만, **요소 수가 적으면 데이터 지역성 때문에 배열이 더 효율**적일 수 있다.
    
- 큐 구현하기
    
    큐는 먼저 입력된 값이 먼저 출력되는 FIFO(선입선출)자료구조이다. 들어간 순서대로 나오는 구조이기 때문에 대기열이 존재한다.
    
    - 들어간 순서 그대로 빠져나오기 때문에 순서가 유지된다.
    - 새로운 요소는 항상 맨 마지막에 추가된다.
    - 출력값은 맨 앞에서 하나씩 빼낸다.
    
    맨 앞에서 부터 출력값이 발생하기 때문에 배열보단 리스트로 구현하는 것이 효율적이다.
    
    ```go
    package main
    
    import (
    	"container/list"
    	"fmt"
    )
    
    type Queue struct { //Queue 구조체 정의
    	v *list.List
    }
    
    func (q *Queue) Push(val interface{}) { //요소 추가
    	q.v.PushBack(val)
    }
    
    func (q *Queue) Pop() interface{} { //요소를 반환하면서 삭제
    	front := q.v.Front()
    	if front != nil {
    		return q.v.Remove(front)
    	}
    	fmt.Printf("%v", front) //다 반환시 리스트에 nil이 있음을 확인
    	return nil
    }
    
    func NewQueue() *Queue {
    	return &Queue{list.New()}
    }
    
    func main() {
    	queue := NewQueue() //새로운 큐 생성
    
    	for i := 1; i <= 10; i++ { //요소 입력
    		queue.Push(i)
    	}
    
    	v := queue.Pop()
    	for v != nil { //요소 출력
    		fmt.Printf("%v -> ", v)
    		v = queue.Pop()
    	}
    }
    //1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> 10 -> <nil>
    ```
    
    1. 리스트를 이용한 큐 구조체를 정의한다. 내부 필드로 리스트를 가지고 있어서 요소를 추가하거나 삭제할 때 리스트(포인터 이용)를 사용한다.
    2. Push()메서드를 생성한다. PushBack()메서드를 이용해 맨 뒤에서 요소를 추가하고 val 빈 인터페이스를 이용해 모든 타입의 데이터를 저장한다.
    3. Pop()메서드를 생성한다. 리스트의 Front()메서드를 이용해 맨 앞의 요소 인스턴스를 반환하고 그 값이 nil이면 리스트가 모두 비었다는 뜻이다. 리스트가 비어있지 않으면 안에 요소들이 있다는 것이므로 Remove()메서드를 호출해 리스트 내에 요소를 삭제하고 그 값을 반환한다.
    4. NewQueue()함수를 이요해 새로운 큐 인스턴스를 만든다. 
- 스택 구현하기
    
    스택은 큐와 달리 FILO자료구조이다. 즉 첫 번째 입력한 요소가 가장 마지막에 출력된다.
    
    - 가장 최근에 넣은 것부터 역순으로 나오게 된다.
    - 요소는 맨 뒤로 추가한다.
    - 요소를 뺄 때는 맨 뒤에서 뺀다.
    
    스택은 순서가 반대가 되기 때문에 가장 최신 것부터 하나씩 되돌릴 때 주로 사용한다. 
    
    큐 - 새로운 요소를 맨 뒤로 추가하고 요소를 뺄 때는 맨 앞에서 뺀다.
    
    스택 - 새로운 요소를 맨 뒤로 추가하고 요소를 뺄 때도 맨 뒤에서 뺀다.
    
    ```go
    package main
    
    import (
    	"container/list"
    	"fmt"
    )
    
    type Stack struct {
    	v *list.List
    }
    
    func NewStack() *Stack {
    	return &Stack{list.New()}
    }
    
    func (s *Stack) Push(val interface{}) {
    	s.v.PushBack(val) //맨 뒤에 요소 추가
    }
    
    func (s *Stack) Pop() interface{} {
    	back := s.v.Back()
    	if back != nil { //맨 뒤에서 요소 반환
    		return s.v.Remove(back)
    	}
    	return nil
    }
    
    func main() {
    	stack := NewStack()
    	for i := 1; i < 5; i++ {
    		stack.Push(i)
    	}
    	val := stack.Pop()
    	for val != nil {
    		fmt.Printf("%v -> ", val)
    		val = stack.Pop()
    	}
    }
    ```
    
    스택은 큐와 구현이 흡사하다. 다른 점은 Pop() 메서드에서 맨 앞에서 요소를 가져오는 게 아니라 맨 뒤에서 요소를 가져온다.
    
    1. 새로운 요소를 추가하는 Push()메서드는 큐와 마찬가지로 PushBack() 메서드로 사용해서 맨 뒤에 요소를 추가한다.
    2. 요소를 반환하는 Pop() 메서드는 맨 앞에서 가져오는 큐와 달리 Back() 메서드를 사용해서 맨 뒤에서 요소를 반환한다.
    

### 링

링은 **맨 뒤의 요소와 맨 앞의 요소가 서로 연결된 자료구조**이다. 리스트를 기반으로 만들어진 자료구조로, 원형으로 연결되어 있기 때문에 환형 리스트라고 불린다. 

링은 시작도 없고 끝도 없다. 다만 현재 위치가 있을 뿐이다.

- 링 기본 사용법
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e47d60d4-76e8-4a93-8ee8-34420d58a926/Untitled.png)
    
    이런 식으로 요소 4.Next()면 요소 1로 연결되어 있다는 것을 볼 수 있다.
    
    ```go
    func main() {
    	r := ring.New(5) //요소가 5개인 링 생성
    	n := r.Len()     //링 길이 변환
    
    	for i := 0; i < n; i++ {
    		r.Value = 'A' + i //순회하면 모든 요소에 값 대입
    		r = r.Next()
    	}
    
    	for j := 0; j < n; j++ {
    		fmt.Printf("%c ", r.Value) //순회하며 값 출력
    		r = r.Next()
    	}
    
    	fmt.Println()
    	for j := 0; j < n; j++ {
    		fmt.Printf("%c ", r.Value) //역순하며 값 출력
    		r = r.Prev()
    	}
    }
    //A B C D E
    //A E D C B
    ```
    
    1. 5개의 요소를 가진 링 자료구조를 만들고 그 첫 번째 요소 인스턴스 반환한다. r은 현재 위치를 나타내는 포인터로서 지금은 첫 번째 요소를 가리킨다.
    2. 각 요솟값을 알파벳 A부터 E까지 설정하고 링의 **Next() 메서드는 다음 요소 인스턴스를 반환**한다. 전체 요소 개수가 5이고 5번 이동하기 때문에 각 요소를 순회하고 현재 위치 r은 다시 첫 번째 요소로 돌아온다. (현재 위치는 다시 한 바퀴 돌아서 ‘A’요소를 가리킨다.
    3. 첫 요소가 ‘A’이므로 순회를 통해서 값을 출력한다.(한 바퀴 돌아서 다시 ‘A’요소를 가리킨다.)
    4. 이번에는 이전 요소들을 돌면서 값을 출력한다. 현재 위치가 A이므로 A부터 출력하고 그 이전 요소인 E,D,C,B 순서로 출력한다.

### 맵

맵은 **키와 값 형태로 데이터를 저장하는 자료구조**이다. 언어에 따라서 딕셔너리, 해시테이블, 해시맵들으로 부르지만, Go 언어에서는 맵이라고 부른다.

맵은 **키와 값의 쌍으로 데이터를 저장하고, 키를 사용해 접근하여 값을 저장하거나 변경**할 수 있다.

- 맵 기본 사용법
    
    맵의 사용법을 코드로 알아보자.
    
    ```go
    package main
    
    import "fmt"
    
    func main() {
    	m := make(map[string]string) //맵 생성
    	m["이화랑"] = "서울시 광진구"
    	m["송하나"] = "서울시 강남구"
    	m["백두산"] = "부산시 사하구" //키와 값 추가
    	m["최번개"] = "전주시 덕진구"
    
    	m["최번개"] = "청주시 상당구" //값 변경
    
    	fmt.Printf("송하나의 주소는 %s입니다.\n", m["송하나"]) //값 출력
    	fmt.Printf("최번개의 주소는 %s입니다.\n", m["최번개"])
    }
    //송하나의 주소는 서울시 강남구입니다.
    //최번개의 주소는 청주시 상당구입니다.
    ```
    
    맵은 리스트나 링과 달리 container 패키지가 아닌 Go 기본 내장 타입이다.
    
    **map[key]value 형태로 맵을 생성**하는데 여기서는 이름으로 주소를 찾으므로 둘 다 문자열로 지정했다. 키와 값을 추가하고 값을 변경할 때도 똑같은 형태로 한다.
    
- 맵 순회
    
    ```go
    type Product struct {
    	Name  string
    	Price int
    }
    
    func main() {
    	m := make(map[int]Product) //맵 생성
    
    	m[16] = Product{"볼펜", 500} //요소추가
    	m[46] = Product{"지우개", 200}
    	m[78] = Product{"자", 1000}
    	m[156] = Product{"샤프", 3000}
    	m[335] = Product{"샤프심", 500}
    
    	for k, v := range m { //맵 순회
    		fmt.Println(k, v)
    	}
    }
    //156 {샤프 3000}
    //335 {샤프심 500}
    //16 {볼펜 500}
    //46 {지우개 200}
    //78 {자 1000}  //정렬되지 않은 값이 출력
    ```
    
    int타입을 키로 Product 타입을 값으로 갖는 맵을 만든다. 이처럼 **키와 값 타입으로 어떤 타입도 사용**할 수 있다. range를 통해 순회할 때 **첫 번째 값으로 키, 두 번째 값으로 값**이 반환된다.
    
    맵은 **내부에서 요소를 보관할 때 입력한 순서와도 키 값과도 상관 없이 데이터를 보관**하기 때문에 정렬되지 않은 값이 출력된다.
    
- 맵 요소 삭제와 없는 요소 확인
    
    delete(m,key)함수로 요소를 삭제한다. **맵 변수와 삭제할 키 값을 차례로 넣으면 해당 요소를 맵에서 삭제**한다. 요소를 조회할 때 키에 알맞는 요소가 없으면 값 타입의 기본값을 반환한다.
    
    ```go
    func main() {
    	m := make(map[int]int) //맵 생성
    	m[1] = 0               //요소 추가
    	m[2] = 1
    	m[3] = 2
    
    	delete(m, 3)      //요소 삭제
    	delete(m, 4)      //없는 요소 삭제 시도
    	fmt.Println(m[3]) //삭제된 요솟값 출력
    	fmt.Println(m[2]) //존재하는 요솟값 출력
    	fmt.Println(m[1])
    
    	v, ok := m[3]
    	v1, ok1 := m[1]
    	fmt.Printf("존재 여부 값 : %d, 불린 : %t\n", v, ok) //요소 확인
    	fmt.Printf("존재 여부 값 : %d, 불린 : %t\n", v1, ok1)
    }
    //0
    //1
    //0
    //존재 여부 값 : 0, 불린 : false
    //존재 여부 값 : 0, 불린 : true
    ```
    
    존재하지 않는 m[4]에 접근해서 삭제를 시도하면 아무런 동작을 하지 않는다.
    
    삭제된 m[3]을 출력하면 값이 0으로 출력되는데 요소가 있는지 없는지 확인하기 위해 복수반환으로 둘 값을 받는다.
    
    v, ok :=m[3]으로 **값과 존재여부를 int와 boolean으로 반환**받아 존재여부를 확인할 수 있다.
    
- 맵, 배열, 리스트 속도 비교
    
    맵은 속도가 매우 빠르다. 삭제, 추가, 읽기에서 요소 개수와 상관없이 속도가 일정하다.
    
    배열은 추가,삭제에서 요소 개수가 많아질수록 오래걸리고 리스트는 요소 읽기에서 요소 개수가 많아질수록 오래걸린다.
    
    하지만 맵은 키와 값의 쌍으로만 동작하기 때문에 인덱스로 접근할 수 없고 일정한 순서가 보장되지 않는다. 또한 배열과 리스트에 비해 상대적으로 메모리를 많이 차지한다.
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a8aed3b2-b1e3-458b-8619-98f3c563d529/Untitled.png)
    
- 맵의 원리
